package db

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/superfly/sprite-env/pkg/tap"
)

// LitestreamConfig holds configuration for Litestream
type LitestreamConfig struct {
	BaseDir           string
	S3AccessKey       string
	S3SecretAccessKey string
	S3EndpointURL     string
	S3Bucket          string
	DatabasePaths     []string
	Logger            *slog.Logger
}

// Litestream manages litestream replication
type Litestream struct {
	config    LitestreamConfig
	logger    *slog.Logger
	cmd       *exec.Cmd
	configDir string
	stopCh    chan struct{}
	stopOnce  sync.Once // Ensures stopCh is closed exactly once
	doneCh    chan struct{}
	errCh     chan error // Reports panics from goroutines
	running   bool
	mu        sync.Mutex
}

// NewLitestream creates a new Litestream instance
func NewLitestream(config LitestreamConfig) (*Litestream, error) {
	if config.Logger == nil {
		config.Logger = slog.Default()
	}

	// Create config directory
	configDir := filepath.Join(config.BaseDir, ".litestream")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create litestream config dir: %w", err)
	}

	ls := &Litestream{
		config:    config,
		logger:    config.Logger,
		configDir: configDir,
		stopCh:    make(chan struct{}),
		doneCh:    make(chan struct{}),
		errCh:     make(chan error, 1), // Buffered to avoid blocking on panic
	}

	// Generate litestream config
	if err := ls.generateConfig(); err != nil {
		return nil, fmt.Errorf("failed to generate litestream config: %w", err)
	}

	return ls, nil
}

// generateConfig creates the litestream.yml configuration file
func (ls *Litestream) generateConfig() error {
	configPath := filepath.Join(ls.configDir, "litestream.yml")

	// Build databases section
	var dbConfigs []string
	for _, dbPath := range ls.config.DatabasePaths {
		dbName := filepath.Base(dbPath)
		dbConfig := fmt.Sprintf(`  - path: %s
    replicas:
      - type: s3
        bucket: %s
        path: litestream/%s
        endpoint: %s
        access-key-id: ${LITESTREAM_ACCESS_KEY_ID}
        secret-access-key: ${LITESTREAM_SECRET_ACCESS_KEY}
        snapshot-interval: 1h
        retention: 6h
        sync-interval: 1s`, dbPath, ls.config.S3Bucket, dbName, ls.config.S3EndpointURL)
		dbConfigs = append(dbConfigs, dbConfig)
	}

	config := fmt.Sprintf(`# Litestream configuration
# Generated by sprite-env

logging:
  level: warn
  type: json
  stderr: false

dbs:
%s
`, strings.Join(dbConfigs, "\n"))

	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write litestream config: %w", err)
	}

	ls.logger.Debug("Generated litestream config", "path", configPath)
	return nil
}

// Start starts litestream replication
func (ls *Litestream) Start(ctx context.Context) error {
	ls.mu.Lock()
	defer ls.mu.Unlock()

	if ls.running {
		return nil
	}

	// Recreate channels if this is a restart (channels were closed during previous Stop)
	// This allows litestream to be stopped and started multiple times
	select {
	case <-ls.stopCh:
		// Channel was closed, recreate it
		ls.stopCh = make(chan struct{})
		ls.stopOnce = sync.Once{} // Reset the Once guard
	default:
		// Channel is still open, first start
	}
	select {
	case <-ls.doneCh:
		// Channel was closed, recreate it
		ls.doneCh = make(chan struct{})
	default:
		// Channel is still open, first start
	}

	// Check if litestream is available
	if _, err := exec.LookPath("litestream"); err != nil {
		ls.logger.Warn("Litestream not found in PATH, skipping replication")
		return nil
	}

	configPath := filepath.Join(ls.configDir, "litestream.yml")

	// First restore any existing backups
	for _, dbPath := range ls.config.DatabasePaths {
		if _, err := os.Stat(dbPath); os.IsNotExist(err) {
			ls.logger.Info("Attempting to restore database from backup", "path", dbPath)
			restoreCmd := exec.CommandContext(ctx, "litestream", "restore", "-config", configPath, dbPath)
			restoreCmd.Env = append(os.Environ(),
				fmt.Sprintf("LITESTREAM_ACCESS_KEY_ID=%s", ls.config.S3AccessKey),
				fmt.Sprintf("LITESTREAM_SECRET_ACCESS_KEY=%s", ls.config.S3SecretAccessKey),
				// Attempt to request JSON logs if supported by litestream
				"LOG_FORMAT=json",
			)

			// Route stdout/stderr to structured logger, using ls.logger (with source label)
			ctxWithLogger := tap.WithLogger(ctx, ls.logger)
			w := tap.WithStructuredLogger(ctxWithLogger)
			if c, ok := w.(interface{ Close() error }); ok {
				defer c.Close()
			}
			restoreCmd.Stdout = w
			restoreCmd.Stderr = w

			if err := restoreCmd.Run(); err != nil {
				ls.logger.Debug("No backup found or restore failed", "path", dbPath, "error", err)
				// Not a fatal error - database might be new
			} else {
				ls.logger.Info("Database restored from backup", "path", dbPath)
			}
		}
	}

	// Start replication
	ls.cmd = exec.Command("litestream", "replicate", "-config", configPath)
	ls.cmd.Env = append(os.Environ(),
		fmt.Sprintf("LITESTREAM_ACCESS_KEY_ID=%s", ls.config.S3AccessKey),
		fmt.Sprintf("LITESTREAM_SECRET_ACCESS_KEY=%s", ls.config.S3SecretAccessKey),
		// Attempt to request JSON logs if supported
		"LOG_FORMAT=json",
	)

	// Set up logging via tap structured writer with ls.logger (source-tagged)
	ctxWithLogger := tap.WithLogger(ctx, ls.logger)
	w := tap.WithStructuredLogger(ctxWithLogger)
	ls.cmd.Stdout = w
	ls.cmd.Stderr = w

	if err := ls.cmd.Start(); err != nil {
		return fmt.Errorf("failed to start litestream: %w", err)
	}

	ls.running = true

	// Monitor litestream in background
	tap.Go(ls.logger, ls.errCh, ls.monitor)

	ls.logger.Info("Litestream replication started", "pid", ls.cmd.Process.Pid)
	return nil
}

// Stop stops litestream replication gracefully
func (ls *Litestream) Stop(ctx context.Context) error {
	ls.mu.Lock()
	if !ls.running {
		ls.mu.Unlock()
		return nil
	}

	if ls.cmd == nil || ls.cmd.Process == nil {
		ls.running = false
		ls.mu.Unlock()
		return nil
	}
	ls.mu.Unlock()

	ls.logger.Info("Stopping litestream...")
	shutdownStart := time.Now()

	// Signal shutdown - sync.Once ensures this is safe to call multiple times
	ls.stopOnce.Do(func() {
		close(ls.stopCh)
	})

	// Try graceful shutdown first
	if err := ls.cmd.Process.Signal(os.Interrupt); err != nil {
		ls.logger.Warn("Failed to send interrupt signal", "error", err)
	}

	// Wait for shutdown - let it take as long as needed
	// Only the parent context cancellation should interrupt this
	select {
	case <-ls.doneCh:
		ls.mu.Lock()
		ls.running = false
		ls.mu.Unlock()
		ls.logger.Info("Litestream stopped gracefully", "duration", time.Since(shutdownStart))
		return nil
	case <-ctx.Done():
		// Context cancelled - force kill
		ls.logger.Warn("Litestream shutdown interrupted, forcing kill",
			"duration", time.Since(shutdownStart))
		if err := ls.cmd.Process.Kill(); err != nil {
			return fmt.Errorf("failed to kill litestream: %w", err)
		}
		<-ls.doneCh
		ls.mu.Lock()
		ls.running = false
		ls.mu.Unlock()
		return fmt.Errorf("litestream shutdown interrupted: %w", ctx.Err())
	}
}

// monitor watches the litestream process
func (ls *Litestream) monitor() {
	defer close(ls.doneCh)
	defer func() {
		ls.mu.Lock()
		ls.running = false
		ls.mu.Unlock()
	}()

	if err := ls.cmd.Wait(); err != nil {
		select {
		case <-ls.stopCh:
			// Expected shutdown
			ls.logger.Debug("Litestream process exited", "error", err)
		default:
			// Unexpected exit
			ls.logger.Error("Litestream process exited unexpectedly", "error", err)
		}
	}
}

// Wait blocks until the monitor goroutine completes or panics
func (ls *Litestream) Wait() error {
	select {
	case <-ls.doneCh:
		return nil
	case err := <-ls.errCh:
		return err
	}
}

// GetPid returns the PID of the litestream process, or 0 if not running
func (ls *Litestream) GetPid() int {
	ls.mu.Lock()
	defer ls.mu.Unlock()

	if ls.cmd != nil && ls.cmd.Process != nil {
		return ls.cmd.Process.Pid
	}
	return 0
}

// (removed unused litestreamLogger)
