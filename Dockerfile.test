# syntax=docker/dockerfile:1
# check=skip=SecretsUsedInArgOrEnv

# Test container that mirrors production environment
# Usage:
#   Build: docker build -f Dockerfile.test -t sprite-env-tests .
#   Run tests: docker run --rm --privileged --cgroupns=host -v "$PWD":/workspace sprite-env-tests

# Download crun binary (same as production)
FROM alpine:3.20 AS crun
ARG TARGETARCH
RUN apk add --no-cache curl
RUN case ${TARGETARCH} in \
        amd64) CRUN_ARCH="amd64" ;; \
        arm64) CRUN_ARCH="arm64" ;; \
        *) echo "Unsupported architecture: ${TARGETARCH}" && exit 1 ;; \
    esac && \
    curl -fL https://github.com/containers/crun/releases/download/1.24/crun-1.24-linux-${CRUN_ARCH} -o /crun && \
    chmod +x /crun

# Get litestream binary (same as production)
FROM litestream/litestream:0.3 AS litestream

# Get juicefs binary (same as production)
FROM ghcr.io/superfly/juicefs:fa0d61a AS juicefs

# Build tmux and utilities (same as production)
FROM alpine:3.20 AS utility-builder
RUN apk add --no-cache \
        build-base \
        musl-dev \
        ncurses-static \
        ncurses-dev \
        libevent-static \
        libevent-dev \
        git \
        autoconf \
        automake \
        pkgconfig \
        bison

WORKDIR /src
RUN git clone --depth 1 --branch 3.5a https://github.com/tmux/tmux.git .
RUN sh autogen.sh && \
    ./configure LDFLAGS="-static" CFLAGS="-O2" && \
    make -j$(nproc)
RUN mkdir -p /system/.sprite/bin && \
    cp tmux /system/.sprite/bin/

# Create /system/etc/hosts
RUN mkdir -p /system/etc && \
    cat > /system/etc/hosts <<EOF
# IPv4
127.0.0.1   localhost
127.0.0.1   sprite

# IPv6
::1         localhost
::1         sprite
EOF

# Download gh CLI
RUN ARCH=$(uname -m) && \
    case ${ARCH} in \
        x86_64) GH_ARCH="amd64" ;; \
        aarch64) GH_ARCH="arm64" ;; \
        *) echo "Unsupported architecture: ${ARCH}" && exit 1 ;; \
    esac && \
    wget -O gh.tar.gz "https://github.com/cli/cli/releases/download/v2.79.0/gh_2.79.0_linux_${GH_ARCH}.tar.gz" && \
    tar -xzf gh.tar.gz && \
    cp gh_2.79.0_linux_${GH_ARCH}/bin/gh /system/.sprite/bin/ && \
    chmod +x /system/.sprite/bin/gh && \
    rm -rf gh.tar.gz gh_2.79.0_linux_${GH_ARCH}

# Assemble system files (same as production)
FROM alpine:3.22 AS assemble-system
COPY --from=utility-builder /system /system
COPY base-env/system/ /system/

# No build stage needed - we build from mounted source at test time

# Final test image - Ubuntu 25.04 (same as production)
FROM ubuntu:25.04

# Install same packages as production plus test dependencies
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && \
    apt-get install -y sqlite3 bash e2fsprogs fio jq nano coreutils \
    lvm2 thin-provisioning-tools drbd-utils \
    parted gdisk util-linux fdisk xfsprogs fuse3 curl iproute2 nftables iputils-ping vim rsync dnsmasq dnsmasq-base socat libcap2-bin \
    # Additional packages for testing
    build-essential git make ca-certificates wget procps netcat-openbsd tmux util-linux dnsutils \
    && apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Explicitly ensure dnsmasq binary exists (some mirrors omit it on first pass)
RUN apt-get update && apt-get install -y dnsmasq dnsmasq-base && command -v dnsmasq

# Install Go early to maximize caching (before COPY commands that might change)
ARG GO_VERSION=1.24.4
ARG TARGETARCH
RUN set -e; \
    case ${TARGETARCH} in \
      amd64) GO_ARCH="amd64" ;; \
      arm64) GO_ARCH="arm64" ;; \
      *) echo "Unsupported TARGETARCH: ${TARGETARCH}" >&2; exit 1 ;; \
    esac; \
    curl -fsSL https://go.dev/dl/go${GO_VERSION}.linux-${GO_ARCH}.tar.gz -o /tmp/go.tgz && \
    rm -rf /usr/local/go && \
    tar -C /usr/local -xzf /tmp/go.tgz && \
    rm -f /tmp/go.tgz

ENV PATH="/usr/local/go/bin:${PATH}"
ENV CGO_ENABLED=1
ENV GOPATH=/go
ENV PATH="${GOPATH}/bin:${PATH}"

# Install tparse for better test output and markdown reporting
RUN go install github.com/mfridman/tparse@latest

# Copy binaries from other stages (same as production)
# These come after Go installation to maximize cache hits
COPY --from=crun /crun /usr/local/bin/crun
COPY --from=litestream /usr/local/bin/litestream /usr/local/bin/litestream
COPY --from=juicefs /usr/local/bin/juicefs /usr/local/bin/juicefs
COPY --from=assemble-system /system /system
# Note: spritectl is built from mounted source at test runtime, not copied here

# Create symlink for sprite environment (tests expect /.sprite)
RUN ln -sf /system/.sprite /.sprite && \
    mkdir -p /.sprite/tmp && \
    useradd -r -s /usr/sbin/nologin sprite-net && \
    setcap 'cap_net_bind_service,cap_net_admin+ep' /usr/sbin/dnsmasq || true

# Set up environment
ENV SPRITE_WRITE_DIR=/tmp/sprite-test \
    SPRITE_HOME=/home/sprite

# Create directories
RUN mkdir -p ${SPRITE_WRITE_DIR} ${SPRITE_HOME}

# Copy base-env contents (for config and scripts)
COPY base-env/ ${SPRITE_HOME}/

# Create a test configuration with JuiceFS in local mode
RUN cat > ${SPRITE_HOME}/test-config.json <<'EOF'
{
  "log_level": "debug",
  "log_json": false,
  "juicefs_local_mode": true,
  "juicefs_base_dir": "/tmp/sprite-test/juicefs"
}
EOF

# Set environment variables for testing
# hadolint ignore=SecretsUsedInArgOrEnv
ENV SPRITE_HTTP_API_TOKEN="test-token-12345" \
    SPRITE_PRIMARY_REGION="test" \
    LOG_LEVEL="debug" \
    SPRITE_OVERLAY_ENABLED="false" \
    SPRITE_CONTAINER_ENABLED="false" \
    SPRITE_JUICEFS_LOCAL_MODE="true" \
    SPRITE_TEST_DOCKER=1 \
    SPRITE_URL="http://localhost:8080" \
    SPRITE_TOKEN="test-token-12345" \
    SPRITE_ADMIN_CHANNEL_URL="https://example.com/internal/whatever" \
    SPRITE_DISABLE_ADMIN_CHANNEL="true" \
    SPRITE_TEST_QUIET_PHX="true"

# FUSE configuration for JuiceFS
RUN echo "user_allow_other" >> /etc/fuse.conf && \
    ln -sf /usr/bin/fusermount3 /bin/fusermount || true

# Set working directory to workspace mount point
WORKDIR /workspace

EXPOSE 8080

# Use spritectl as entrypoint just like production
#ENTRYPOINT ["/usr/local/bin/spritectl", "-config", "/home/sprite/test-config.json", "-listen", "0.0.0.0:8080"]